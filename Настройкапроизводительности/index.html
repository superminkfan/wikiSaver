<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Настройка производительности</title>
    <style>
        body { display: flex; font-family: sans-serif; }
        nav { width: 250px; background: #f0f0f0; padding: 1em; height: 100vh; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        main { flex-grow: 1; padding: 2em; }
        .current > a { font-weight: bold; }
        a { text-decoration: none; color: #0366d6; }
        ul { list-style-type: none; padding-left: 1em; }
        li { margin-bottom: 0.5em; }
    </style>
</head>
<body>
    <nav><ul><li class="current"><a href="index.html">Настройка производительности</a></li></ul></nav>
    <main><h1>Настройка производительности</h1><p><span style="color: rgb(23,43,77);">Проблемы с недостаточной производительностью и ее падением в DataGrid могут возникать по описанным ниже причинам.</span></p><h2 id="id-Настройкапроизводительности-Проблемысаппаратнымиресурсами">Проблемы с аппаратными ресурсами</h2><p><span style="color: rgb(23,43,77);">DataGrid активно</span><span style="color: rgb(23,43,77);"> </span><span style="color: rgb(23,43,77);">нагружает</span><span style="color: rgb(23,43,77);"> CPU, оперативную память, дисковую подсистему и сеть.</span><span style="color: rgb(23,43,77);"> </span><span style="color: rgb(23,43,77);">Из-за этого сбой или просадка производительности</span><span style="color: rgb(23,43,77);"> </span><span style="color: rgb(23,43,77);">в любом из перечисленных компонентов приведет к падению производительности или аварийному завершению работы узлов DataGrid.</span></p><h3 id="id-Настройкапроизводительности-ВыcокаяутилизацияCPU">Выcокая утилизация CPU</h3><p><span style="color: rgb(23,43,77);">Подробнее о CPU написано в подразделе [«Высокая утилизация CPU»](troubleshooting-guide.md)</span><span style="color: rgb(23,43,77);"> раздела «</span><span style="color: rgb(23,43,77);">Часто встречающиеся проблемы и пути их устранения</span><span style="color: rgb(23,43,77);">»</span><span style="color: rgb(23,43,77);">.</span></p><h3 id="id-Настройкапроизводительности-Потеряпроизводительностииз-задисковойподсистемы">Потеря производительности из-за дисковой подсистемы</h3><h4 id="id-Настройкапроизводительности-Высокаяутилизациядисков">Высокая утилизация дисков</h4><p>Достаточно распространены сценарии, в которых из-за высокой нагрузки дисковая подсистема перестает справляться с поступающим количеством запросов. Диагностировать такую ситуацию помогают различные средства мониторинга аппаратных ресурсов. Например, если на хосте настроена сборка `nmon`, загруженность дисков поможет определить метрика `DISKBUSY`. Если ее значение приближается к 100%, дисковая подсистема перегружена. </p><p>Если нагрузочное тестирование показывает, что диски часто полностью утилизированы, воспользуйтесь одним из вариантов решения проблемы:</p><ul><li>замена дисков на более быстрые;</li><li>добавление узлов в кластер, чтобы нагрузка распределилась по большему количеству узлов;</li><li>корректная настройка Persistance — подробнее о ней написано<span> </span><span style="color: rgb(23,43,77);">в разделе [«Настройка Persistence»](..<span class="">/</span>../developer-guide/md/setting_up_persistence.md</span><span style="color: rgb(23,43,77);">) документа «Руководство прикладного разработчика».</span></li></ul><h4 id="id-Настройкапроизводительности-Деградациядисков">Деградация дисков </h4><p>Потеря производительности также возможна из-за деградации дисковой подсистемы. Характерные признаки подобного сценария — высокая утилизация дисков на фоне небольшого количества операций ввода/вывода за единицу времени. В данном случае рекомендуется вывести узел из топологии для замены дисков. </p><h4 id="id-Настройкапроизводительности-PageReplacement(заменастраниц)">Page Replacement (замена страниц)</h4><p><span>Page Replacement — вытеснение неиспользуемых страниц из ОЗУ и чтение страниц с нужными данными с диска.</span></p><p>Если размер региона данных превышает объем доступной DataGrid оперативной памяти, рано или поздно запрашиваемые данные перестанут помещаться в память. В этом случае DataGrid будет вытеснять одни данные на диск и читать с него другие данные. Обращение к данным будет занимать более длительное время, чем при чтении из памяти. Если тестирование показывает, что с началом Page Replacement производительность кластера упала, воспользуйтесь одним из вариантов:</p><ul><li>Увеличьте объем оперативной памяти на серверных узлах. Это позволит поднять большее количество данных в оперативную память.</li><li>Добавьте серверные узлы в топологию. Это позволит уменьшить количество данных, которые хранятся на каждом узле, и увеличить процент данных, которые можно хранить в памяти.</li></ul><h3 id="id-Настройкапроизводительности-Сетевыесбои">Сетевые сбои</h3><p>Сбои на промежуточном сетевом оборудовании и/или сетевых портах серверных и клиентских узлов могут привести к задержке ответов и потере или нарушению порядка доставки сообщений различных SPI DataGrid. За этим может последовать снижение производительности кластера и нарушение топологии. </p><p>В DataGrid есть возможность настроить тайм-ауты, которые влияют на сетевое взаимодействие узлов. Подробнее о них написано в подразделе [«Настройка сети»](..<span class="">/</span>../developer-guide/md/<span style="color: rgb(23,43,77);">network_setup.md</span>) документа «Руководство прикладного разработчика». Существует две стратегии настройки сетевых тайм-аутов:</p><ul><li>Первая направлена на сохранение всех узлов в топологии на фоне сетевых сбоев.<span> </span>В этом случае стоит выставлять высокие значения для сетевых тайм-аутов. В результате узлы будут считаться недоступными через больший интервал времени и<span> </span>будет предприниматься больше попыток переподключения. Обратная сторона<span> </span>подхода — возможное падение производительности в некоторых операциях или во всем кластере.</li><li>Вторая стратегия настройки сетевых таймаутов — выставлять сравнительно низкие значения, чтобы узел со сбоем раньше обнаружили и вывели из топологии. Так обеспечивается минимальное падение<span> </span><span>производительности. При такой настройке важно помнить, что чем раньше узел удаляется из тополгии, тем выше вероятность потери или неконсистентности данных. </span></li></ul><h2 id="id-Настройкапроизводительности-Некорректнаянастройкаоперационнойсистемы">Некорректная настройка операционной системы</h2><h3 id="id-Настройкапроизводительности-Настройкапараметровядра">Настройка параметров ядра</h3><p>Для получения максимальной производительности кластера DataGrid в высоконагруженных сценариях нужна дополнительная настройка параметров ядра операционной системы на клиентских и серверных узлах. Подробнее о настройке написано в разделе [«<span>Параметры SYSCTL»</span>](<span style="color: rgb(23,43,77);">sysctl-parameters.md</span>).</p><h3 id="id-Настройкапроизводительности-ОтключениеTransparentHugePages"><span class="inline-comment-marker" data-ref="4606f295-cfd4-41bd-9c1e-32408a15dc86">Отключение Transparent Huge Pages</span></h3><p>DataGrid самостоятельно управляет памятью и размером страниц. Transparent Huge Pages (THB) — механизм, который прозрачным для приложения образом динамически организует выделение памяти «огромными» страницами (<span style="color: rgb(23,43,77);">страницы оперативной памяти, размер которых значительно превышает стандартный</span>). С одной стороны, использование THB вместе с DataGrid избыточно. С другой стороны, использование THB сопровождается накладными расходами, например может спровоцировать высокую утилизацию CPU и длительные JVM-паузы. </p><p>На узлах DataGrid включение THB не принесет пользы, но с высокой вероятностью вызовет проблемы с производительностью. Этот механизм следует отключать на серверных и клиентских узлах DataGrid. </p><p>Чтобы посмотреть текущую конфигурацию THB, используйте команду:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: bash; gutter: false; theme: Confluence" data-theme="Confluence">cat /sys/kernel/mm/transparent_hugepage/enabled</pre>
</div></div><p><span style="color: rgb(23,43,77);">Если вернулось значение</span><span style="color: rgb(23,43,77);"> `</span><span style="color: rgb(23,43,77);">always`, отключите THB:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: bash; gutter: false; theme: Confluence" data-theme="Confluence">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled
echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</pre>
</div></div><h3 id="id-Настройкапроизводительности-Многопроцессорныесерверныемашины,NUMA"><span style="color: rgb(23,43,77);">Многопроцессорные серверные машины, NUMA</span></h3><p><span style="color: rgb(23,43,77);">NUMA (Non-Uniform Memory Access) — <span>дизайн памяти, при котором у некоторого количества ядер процессора есть быстрый доступ к какой-то части оперативной памяти непосредственно через контроллер. </span></span><span style="color: rgb(23,43,77);">Если для исполнения потоков этой памяти недостаточно, ядра могут получить доступ к другим участкам памяти с помощью шины данных. В первом случае память называется локальной, во втором — удаленной. Доступ к локальной памяти по времени дешевле, чем к удаленной (выгода зависит от конкретной реализации и сценариев эксплуатации, может достигать 40%).</span></p><p><span style="color: rgb(23,43,77);"> Совокупность ядер и их локальной памяти называют NUMA-узлом. </span></p><p><span style="color: rgb(23,43,77);">Увеличение производительности можно ожидать на многопроцессорных машинах с большим объемом оперативной памяти. </span></p><h4 id="id-Настройкапроизводительности-NUMA-awareвыделениепамятивосновномрегионеDataGrid"><span style="color: rgb(23,43,77);">NUMA-aware выделение памяти в основном регионе DataGrid</span></h4><p><span style="color: rgb(23,43,77);">Задача оптимизации программного обеспечения с учетом архитектуры NUMA (NUMA-aware) — по возможности разместить на одном NUMA-узле потоки и данные, которыми они оперируют. Если требуется аллоцировать участок памяти, который превышает объем памяти одного NUMA-узла, страницы такого участка стоит равномерно размещать по всем NUMA-узлам. </span></p><p>Поддержка NUMA реализована в DataGrid для аллокации памяти регионов данных. Перед включением поддержки NUMA в DataGrid:</p><ol><li>Убедитесь, что использование NUMA не отключено в конфигурации загрузчика. В файле `/etc/default/grub` в строке `GRUB_CMDLINE_LINUX` не должно быть инструкции `numa=off`.</li><li>Убедитесь, что на сервере установлена библиотека<span> `</span><span style="color: rgb(31,35,40);">libnuma-2.0.x`.</span></li><li>Убедитесь, что на сервере установлен и запущен `numactl`.</li><li>Выберите стратегию аллокации и настройте регионы данных в соответствии с ней.</li></ol><p><span style="color: rgb(23,43,77);">Поддержка NUMA в Linux реализована<span> </span>с помощью библиотеки `libnuma`. Ниже описаны стратегии аллокации, которые позволяет реализовать API `libnuma`.</span></p><p><strong>Простая (simple) аллокация:</strong></p><ol><li>Выделение памяти для процесса/потока согласно NUMA-политике по умолчанию. Использует<span> </span><span> `void *numa_alloc(size_t)`</span>:</li></ol><p><br/></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Allocation with default NUMA policy for thread/process, uses `void *numa_alloc(size_t)` under the hood:</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: xml; gutter: false; theme: Confluence" data-theme="Confluence">&lt;property name="dataStorageConfiguration"&gt;
    &lt;bean class="org.apache.ignite.configuration.DataStorageConfiguration"&gt;
        &lt;property name="defaultDataRegionConfiguration"&gt;
            &lt;bean class="org.apache.ignite.configuration.DataRegionConfiguration"&gt;
                &lt;property name="name" value="Default_Region"/&gt;
                ....
                &lt;property name="memoryAllocator"&gt;
                    &lt;bean class="org.apache.ignite.mem.NumaAllocator"&gt;
                        &lt;constructor-arg&gt;
                            &lt;bean class="org.apache.ignite.mem.SimpleNumaAllocationStrategy"/&gt;
                        &lt;/constructor-arg&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;</pre>
</div></div><p><span style="color: rgb(31,35,40);">2. Выделение памяти на указанном<span> </span></span><span style="color: rgb(23,43,77);">NUMA-узле. Использует `<span>void *numa_alloc_onnode(size_t, int)</span>`</span><span style="color: rgb(23,43,77);">:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Allocation on specific NUMA node, uses `void *numa_alloc_onnode(size_t, int)` under the hood:</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: xml; gutter: false; theme: Confluence" data-theme="Confluence">&lt;property name="dataStorageConfiguration"&gt;
    &lt;bean class="org.apache.ignite.configuration.DataStorageConfiguration"&gt;
        &lt;property name="defaultDataRegionConfiguration"&gt;
            &lt;bean class="org.apache.ignite.configuration.DataRegionConfiguration"&gt;
                &lt;property name="name" value="Default_Region"/&gt;
                ....
                &lt;property name="memoryAllocator"&gt;
                    &lt;bean class="org.apache.ignite.mem.NumaAllocator"&gt;
                        &lt;constructor-arg&gt;
                            &lt;bean class="org.apache.ignite.mem.SimpleNumaAllocationStrategy"&gt;
                                &lt;constructor-arg name="node" value="0"/&gt;
                            &lt;/bean&gt;
                        &lt;/constructor-arg&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;</pre>
</div></div><p><strong>Чередующаяся (interleaved) аллокация:</strong></p><ol><li>Чередующееся распределение на всех NUMA-узлах. Использует<span> `void *numa_alloc_interleaved(size_t)`</span>:</li></ol><p><br/></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Interleaved allocation on all NUMA nodes, uses `void *numa_alloc_interleaved(size_t)` under the hood:</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: xml; gutter: false; theme: Confluence" data-theme="Confluence">&lt;property name="dataStorageConfiguration"&gt;
    &lt;bean class="org.apache.ignite.configuration.DataStorageConfiguration"&gt;
        &lt;property name="defaultDataRegionConfiguration"&gt;
            &lt;bean class="org.apache.ignite.configuration.DataRegionConfiguration"&gt;
                &lt;property name="name" value="Default_Region"/&gt;
                ....
                &lt;property name="memoryAllocator"&gt;
                    &lt;bean class="org.apache.ignite.mem.NumaAllocator"&gt;
                        &lt;constructor-arg&gt;
                            &lt;bean class="org.apache.ignite.mem.InterleavedNumaAllocationStrategy"/&gt;
                        &lt;/constructor-arg&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;</pre>
</div></div><p><span style="color: rgb(23,43,77);">2. Чередующееся распределение на указанных NUMA-узлах. Использует `</span><span style="color: rgb(23,43,77);">void </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">*</span><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1" style="color: rgb(23,43,77);">numa_alloc_interleaved_subset(size_t, struct bitmask</span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">*</span><span style="color: rgb(23,43,77);">)`:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>Interleaved allocation on specified NUMA nodes, uses `void <strong>numa_alloc_interleaved_subset(size_t, struct bitmask</strong>)` under the hood:</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: xml; gutter: false; theme: Confluence" data-theme="Confluence">&lt;property name="dataStorageConfiguration"&gt;
    &lt;bean class="org.apache.ignite.configuration.DataStorageConfiguration"&gt;
        &lt;property name="defaultDataRegionConfiguration"&gt;
            &lt;bean class="org.apache.ignite.configuration.DataRegionConfiguration"&gt;
                &lt;property name="name" value="Default_Region"/&gt;
                ....
                &lt;property name="memoryAllocator"&gt;
                    &lt;bean class="org.apache.ignite.mem.NumaAllocator"&gt;
                        &lt;constructor-arg&gt;
                            &lt;bean class="org.apache.ignite.mem.InterleavedNumaAllocationStrategy"&gt;
                                &lt;constructor-arg name="nodes"&gt;
                                    &lt;array&gt;
                                        &lt;value&gt;0&lt;/value&gt;
                                        &lt;value&gt;1&lt;/value&gt;
                                    &lt;/array&gt;
                                &lt;/constructor-arg&gt;
                            &lt;/bean&gt;
                        &lt;/constructor-arg&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;</pre>
</div></div><p><strong>Аллокация на локальном узле (local node allocation):</strong></p><p><span style="color: rgb(0,0,0);">Выделение памяти на локальном для процесса NUMA-узле. Использует `<span>void* numa_alloc_onnode(size_t)</span>`: </span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: xml; gutter: false; theme: Confluence" data-theme="Confluence">&lt;property name="dataStorageConfiguration"&gt;
    &lt;bean class="org.apache.ignite.configuration.DataStorageConfiguration"&gt;
        &lt;property name="defaultDataRegionConfiguration"&gt;
            &lt;bean class="org.apache.ignite.configuration.DataRegionConfiguration"&gt;
                &lt;property name="name" value="Default_Region"/&gt;
                ....
                &lt;property name="memoryAllocator"&gt;
                    &lt;bean class="org.apache.ignite.mem.NumaAllocator"&gt;
                        &lt;constructor-arg&gt;
                            &lt;constructor-arg&gt;
                                &lt;bean class="org.apache.ignite.mem.LocalNumaAllocationStrategy"/&gt;
                            &lt;/constructor-arg&gt;
                        &lt;/constructor-arg&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;</pre>
</div></div><p><span style="color: rgb(23,43,77);">В большей части сценариев оптимальным выбором будет стратегия чередующейся аллокации на всех NUMA-узлах (interleaved allocation on all NUMA nodes). С ней все страницы региона данных будут равномерно распределены между всеми NUMA-узлами. </span></p><h4 id="id-Настройкапроизводительности-NUMA-оптимизациядляheapвG1GC">NUMA-оптимизация для heap в G1 GC</h4><p>На Java версии 8 и новее можно включить NUMA-оптимизацию для сборщика мусора G1 (подробнее о его настройке написано ниже в разделе [«Сборка мусора (GC)»](#сборка-мусора-gc)). Лучшие результаты эта оптимизация показывает на Java версии 14 и новее. Это связано с тем, что<span> </span>для версий ниже 14 реализована<span> </span>только чередующаяся аллокация heap.</p><p>В Java версии 14 и новее реализована поддержка NUMA-aware. Heap разделяется на сегменты, которые аллоцируются на NUMA-узлы. На этих же узлах работают потоки приложения или серверного узла DataGrid (мутаторы, mutators), которые связаны с сегментами. </p><p>Чтобы включить NUMA для G1, добавьте JVM-опцию <span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:+UseNUMA</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span style="color: rgb(34,34,34);">.</span></p><h2 id="id-Настройкапроизводительности-ЗадержкиввиртуальноймашинеJava(JVM)">Задержки в виртуальной машине Java (JVM)</h2><p><span style="color: rgb(23,43,77);">Настройка продукта для сценариев с низкими задержками (low-latency) отличается от настроек для повышения пропускной способности. Не существует единых настроек продукта и виртуальной машины Java (JVM) под все проекты. </span><span style="color: rgb(23,43,77);">Конечный набор опций, который подходит для конкретного<span> </span>проекта, определяется<span> </span>во время нагрузочного тестирования. </span></p><p><span style="color: rgb(23,43,77);">Для ряда продуктов требуется обеспечивать низкие задержки в ответах пользователям и снижать время пауз. Их могут<span> </span>вызвать:<br/>- задержки в работе<span> </span>оборудования и паузы<span> </span>в работе виртуальной машины;<br/>- длительные сборки мусора JVM (GC);<br/>- накопление данных для постоянного хранилища (Peristence), с которыми не справляется дисковая подсистема.</span></p><p><span style="color: rgb(23,43,77);">Определить наличие пауз в работе DataGrid можно с помощью мониторинга и в журналах. Если в работе JVM есть задержки,</span><span> в log-файле </span><span style="color: rgb(0,51,102);">`ignite.log` будут присутствовать сообщения `Possible too long JVM pause`</span>. <span style="color: rgb(23,43,77);">Ниже описаны JVM-опции, которые могут влиять на паузы в работе<span> </span>машины и помогут<span> </span>обнаружить проблемы с оборудованием.</span></p><h3 id="id-Настройкапроизводительности-Структурапауз"><span style="color: rgb(23,43,77);">Структура пауз</span></h3><p><span style="color: rgb(23,43,77);">Для выполнения операции GC или другой системной операции виртуальной машине нужно остановить все потоки приложения.<br/><br/></span></p><p><img alt="(warning)" class="emoticon emoticon-warning" data-emoticon-name="warning" src="attachments/warning.svg"/> Перенести изображение в папку <span style="color: rgb(0,51,102);">resources!</span></p><p><span style="color: rgb(0,51,102);">![](resources/pause-structure.png)</span></p><p><div class="aui-message error shadowed conf-macro output-inline conf-macro output-block" data-hasbody="false" data-macro-name="drawio">
<p class="title">
<img src="attachments/L1HhcJz8Ry8yDQvX9zOzVMWzd0H1yRyWyg3fy+3n90LRT8AtTXGLLt2DBwAAAAASUVORK5CYII=" style="width : 12px"/>
		draw.io
	</p>
			Diagram attachment access error: cannot display diagram
	</div>
</p><p>Для отладки и определения причины слишком долгой JVM-паузы обязательно нужно включить опции записи журналов сборщика мусора, а также<span> </span>опции:</p><pre><span style="color: rgb(0,0,128);">- </span><span style="color: rgb(128,128,128);">`-XX:+PrintGCApplicationStoppedTime` </span>— выдает время приостановки для всех пауз (остановка в safepoint + общее время пауз);<br/><span style="color: rgb(0,0,128);">- <span style="color: rgb(128,128,128);">`–XX:+PrintSafepointStatistics`</span></span><span style="color: rgb(128,128,128);"> </span>и <span style="color: rgb(128,128,128);">`-XX:PrintSafepointStatisticsCount=1`</span><span style="color: rgb(128,128,128);"> </span>— после каждого safepoint будет сообщаться время и причина.</pre><p>Если опции установлены корректно, в журнале сборщика мусора `gc-safepoint` будут присутствовать сообщения<span> </span>вида:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Total time for which application threads were stopped: 0.2019948 seconds, Stopping threads took: 0.0004585 seconds</pre>
</div></div><p>Первое значение показывает, сколько всего секунд ушло на паузу: остановку потоков и саму операцию. Второе значение показывает, в течение какого времени JVM пыталась их остановить.</p><p>Если остановка потоков произошла быстро (как в примере выше), но общее время паузы значительное — проверьте, что происходило<span> </span>в момент паузы. Скорее всего, происходила сборка мусора (GC). Ее настройка описана в следующем разделе.</p><p>Пример другого поведения — пауза, которую вызвала не сборка<span> </span>мусора:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Total time for which application threads were stopped: 2.6714757 seconds, Stopping threads took: 2.6679943 seconds</pre>
</div></div><p><span style="color: rgb(23,43,77);">В данном примере 2 секунды потребовалось на остановку потоков в безопасном состоянии, а на саму операцию было потрачено меньше 0,01 секунды. В примере время остановки и паузы одинаковое — это означает, что полезной работы GC не совершал и все затраченное время потоки пытались попасть в точку<span> </span></span><span style="color: rgb(23,43,77);">остановки</span><span style="color: rgb(23,43,77);"> (safepoint). Разбор<span> данного примера есть ниже в разделе [</span></span><span style="color: rgb(23,43,77);">«Долгая остановка потоков»](#долгая-остановка-потоков).</span></p><h3 id="id-Настройкапроизводительности-Сборкамусора(GC)">Сборка мусора (GC)</h3><p><span style="color: rgb(23,43,77);">В данном разделе описываются некоторые опции, которые помогут снизить задержки в работе сборщика мусора (GC). Для DataGrid рекомендуется использовать сборщик G1 (устанавливается по умолчанию с Java версии 11 и новее).</span></p><h4 id="id-Настройкапроизводительности-Размерheap">Размер heap</h4><p>Перед тонкой настройкой GC проверьте, что объем heap подходит данному проекту. Если объем памяти слишком маленький, у сборщика мусора не будет достаточного запаса для управления памятью — это приведет к паузам. Если объем памяти слишком большой, могут возникнуть паузы из-за накопления слишком большого объема неосвобожденных объектов.</p><p>Продукт использует heap JVM для хранения:</p><ul><li>всех незавершенных транзакций от всех клиентов<span> </span>платформы;</li><li>результатов SQL-запросов (result set)<span> </span><span style="color: rgb(23,43,77);">в размере страницы или<span> </span></span>в полном объеме<span> </span>(если отключен флаг `lazy` или в запросе присутствует<span> </span>сортировка).</li></ul><p><span>Перед нагрузочным тестированием для выбора первых значений опции </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-Xmx</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span> можно оценить объем heap на каждом узле как:</span><br/><br/><span>```text</span><br/><span>count\</span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">*</span><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1">size\</span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">*</span><span>concurrency/nodes</span><br/><span>```</span><br/><span>Гдe:</span></p><ul><li><span>`count` — количество записей в результате выполнения запроса;</span></li><li><span>`size` — максимальный размер записи;</span></li><li><span>`concurrency` — максимальное количество параллельных клиентов;</span></li><li><span>`nodes` — количество узлов.</span></li></ul><p><span>Данная оценка является примерной. </span><span>Обычно размер heap выбирают меньше 32 Гб, так как в этом случае hotspot JVM более компактно хранит данные в памяти (за счет размера указателя).</span></p><h4 id="id-Настройкапроизводительности-Уменьшениеразмераyoung-поколения">Уменьшение размера young-поколения</h4><p><span>В некоторых случаях (обычно при большом heap) может потребоваться уменьшить размер young-поколения. <span style="color: rgb(23,43,77);">Признаки, что размер young-поколения</span><span style="color: rgb(23,43,77);"> стоит уменьшить</span>:</span><br/><br/><span>1. Наблюдаются длительные сборки мусора (GC-паузы), среди которых подавляющее большинство являются young-паузами (в GC-логах — Pause Young (Normal) (G1 Evacuation Pause)).</span><br/><span>2. Большую часть пауз составляет фаза Object copy (подробнее о ней написано ниже в разделе [«</span>Длительность Object copy<span>»](#длительность-object-copy)).</span><br/><br/><span>Размер young-поколения задается в пределах процентных значений, которые задаются параметрами </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:G1NewSizePercent=n</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span> (по умолчанию 5) и </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:G1MaxNewSizePercent=m</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span> (по умолчанию 60).</span><br/><br/><span>При неинтенсивных нагрузках может помочь уменьшение минимального размера young-поколения с 5% до 1–3%. Если heap достаточно часто и интенсивно наполняется, это может привести к его заполнению на 60% и более и к увеличению времени сборки мусора. В таких случаях стоит уменьшить максимальный размер young-поколения. Точных рекомендаций нет, следует исходить из интенсивности заполнения young-поколения и скорости очистки сборщиком мусора.</span></p><h4 id="id-Настройкапроизводительности-Примервычисленияразмераyoung-поколения">Пример вычисления размера young-поколения</h4><p><span style="color: rgb(51,51,51);">&gt; <strong>Внимание</strong><br/>&gt;<br/></span><span style="color: rgb(51,51,51);">&gt; Данный пример носит исключительно иллюстрационный характер и позволяет грубо оценить максимальный размер young-поколения. От этого значения можно отталкиваться на фазе НТ-тестирования. Даже если размер young-поколения подобран точно, периодически из-за внутренних механизмов<span> </span>JVM возможны более длительные<span> </span></span>паузы, чем<span style="color: rgb(51,51,51);"><span> </span>ожидалось</span>. Д<span style="color: rgb(51,51,51);">анный момент требует тщательного тестирования.</span></p><p><strong><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1">Исходные данные:</span></strong><br/><br/><span>- 30 Гб — размер heap.</span><br/><span>- 15 Гб — средний размер young-поколения при долгих паузах. О том, как определить размер для единичной паузы, написано в следующем разделе.</span><br/><span>- 1,5 с — средняя длительность максимального времени фазы Object copy во время долгих пауз. О том, как определить длительность для единичной паузы, написано ниже в разделе [«Длительность Object copy»](#длительность-object-copy).</span><br/><span>- 50 мс — желаемый максимальный размер паузы.</span><br/><br/><strong><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1">Вычисление:</span></strong><br/><br/><span>1. 15 </span><span class="">/</span><span> 1,5 = 10 Гб</span><span class="">/</span><span>с — средняя скорость очистки heap.</span><br/><span>2. 0,05 с \* 10 Гб/с = 0,5 Гб — целевой максимальный размер young-поколения.</span><br/><span>3. 0,5 Гб </span><span class="">/</span><span> 30 Гб \* 100% = 1,67% — целевой максимальный размер young-поколения (в процентах от максимального размера heap).</span><br/><br/><strong><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1">Результат и выводы:</span></strong><br/><br/><span>- </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:G1MaxNewSizePercent=2</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span> (округление 1,67% в большую сторону);</span><br/><span>- </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:G1NewSizePercent=1</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span> (должен быть меньше </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">G1MaxNewSizePercent</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1">`</span><span>, который в данном случае равен 2).</span><br/><br/><span>Если для продукта достаточно таких размеров young-поколения, при постоянно пустом old-поколении размер heap в 30 Гб избыточен.</span><br/><br/><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1">&gt; <strong>Важно<br/></strong></span>&gt;<br/>&gt; Обратите внимание:<br/><span>&gt;<br/>&gt; 1. Все ли паузы длинные? Часто бывает, что длинными являются только единичные паузы (остальные в пределах нормы). В этом случае нужно уменьшить только размер длинных пауз и при вычислении опираться на их средние значения. Если в целом все паузы достаточно длинные, можно выбрать среднее значение пауз в целом.<br/></span><span>&gt; 2. Долгая фаза только Object copy? Если фаза Object copy не составляет большую часть паузы, проблема длительных пауз скорее всего не связана с размером young-поколения.</span></p><h4 id="id-Настройкапроизводительности-Определениеразмераyoung-поколенияизлоговGC">Определение размера young-поколения из логов GC</h4><p><span>До и после каждой паузы выводится статистика размеров областей young-поколения:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">GC(25)   region size 8192K, 2380 young (19496960K), 8 survivors (65536K)
...
GC(25)   region size 8192K, 7 young (57344K), 7 survivors (57344K)</pre>
</div></div><p><span style="color: rgb(23,43,77);">Размер young-поколения, который был очищен:</span><br/><br/><span class="style-TextBoldStyle__cls2 style-TextBoldStyle__cls1 style-TextItalicStyle__cls2 style-TextItalicStyle__cls1" style="color: rgb(23,43,77);">19496960K - 57344K = 19439616К = 18,54 Гб</span></p><h4 id="id-Настройкапроизводительности-ДлительностьObjectcopy">Длительность Object <span class="inline-comment-marker" data-ref="79037406-1d26-4bf8-ba6e-b7f600ae190a">copy</span></h4><p><br/></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">GC(7)     Object Copy (ms):         Min:  9.3, Avg: 43.1, Max: 193.5, Diff: 184.2, Sum: 4866.5, Workers: 113
...
GC(7) User=5.08s Sys=1.49s Real=0.23s</pre>
</div></div><p><span style="color: rgb(23,43,77);">Ориентироваться следует на значение </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">Max: 193.5</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);"> мс для Object copy. Оно составляет большую часть паузы: </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">Real=0.23s</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);">.</span></p><h4 id="id-Настройкапроизводительности-ДлительностьGCWorkerOther">Длительность GC Worker <span class="inline-comment-marker" data-ref="c6cf7214-7b29-4079-9735-62c9d7d86128">Other</span></h4><p>При длительной GC-паузе обратите внимание на GC Worker Other — время для каждого GC-потока, которое нельзя отнести к ранее перечисленным фазам в GC-log (время, которое рабочий поток провел вне GC).<span> </span>Оно должно быть достаточно низким. Высокие значения связаны с узкими местами в других частях JVM, например активность JVM, которая приводит к остановке GC-потока. Эта часть времени не тратится на сборку мусора, но записывается как часть log-файла.</p><p>GC Worker Total — сводные данные по GC включают в себя общее время выполнения GC и время на GC Worker Other.</p><p>При наличии высоких значений GC Worker Other стоит обратиться в поддержку JVM и к специалистам Linux.</p><div class="table-wrap"><table class="wrapped confluenceTable" style="text-align: left;"><tbody class="" style="text-align: left;"><tr class="" style="text-align: left;"><td class="confluenceTd" style="text-align: left;"><p style="text-align: left;"><code class="java plain" style="text-align: left;">GC(</code><code class="java value" style="text-align: left;">20086</code><code class="java plain" style="text-align: left;">) GC Worker Other (ms): Min:<span> </span></code><code class="java value" style="text-align: left;">1120.0</code><code class="java plain" style="text-align: left;">, Avg:<span> </span></code><code class="java value" style="text-align: left;">28525.1</code><code class="java plain" style="text-align: left;">, Max:<span> </span></code><code class="java value" style="text-align: left;">38447.5</code><code class="java plain" style="text-align: left;">, Diff:<span> </span></code><code class="java value" style="text-align: left;">37327.5</code><code class="java plain" style="text-align: left;">, Sum:<span> </span></code><code class="java value" style="text-align: left;">1083955.5</code><code class="java plain" style="text-align: left;">, Workers:<span> </span></code><code class="java value" style="text-align: left;">38</code><br/><code class="java plain" style="text-align: left;">GC(</code><code class="java value" style="text-align: left;">20086</code><code class="java plain" style="text-align: left;">) GC Worker Total (ms): Min:<span> </span></code><code class="java value" style="text-align: left;">2237.2</code><code class="java plain" style="text-align: left;">, Avg:<span> </span></code><code class="java value" style="text-align: left;">29642.4</code><code class="java plain" style="text-align: left;">, Max:<span> </span></code><code class="java value" style="text-align: left;">39564.6</code><code class="java plain" style="text-align: left;">, Diff:<span> </span></code><code class="java value" style="text-align: left;">37327.4</code><code class="java plain" style="text-align: left;">, Sum:<span> </span></code><code class="java value" style="text-align: left;">1126410.7</code><code class="java plain" style="text-align: left;">, Workers:<span> </span></code><code class="java value" style="text-align: left;">38</code><br/><code class="java plain" style="text-align: left;">...</code><br/><code class="java plain" style="text-align: left;">GC(</code><code class="java value" style="text-align: left;">20086</code><code class="java plain" style="text-align: left;">) User=</code><code class="java value" style="text-align: left;">1</code><code class="java plain" style="text-align: left;">.07s Sys=</code><code class="java value" style="text-align: left;">2</code><code class="java plain" style="text-align: left;">.01s Real=</code><code class="java value" style="text-align: left;">184</code><code class="java plain" style="text-align: left;">.24s</code></p></td></tr></tbody></table></div><h3 id="id-Настройкапроизводительности-Parallelthreads">Parallel threads</h3><p>Опция регулирует количество параллельных сборщиков мусора.</p><p>В некоторых ситуациях (например, когда логических ядер процессора больше 100) возможны длительные GC-паузы из-за долгой синхронизации множества потоков между собой во время сборок мусора. В этом случае уменьшение количества потоков может снизить GC-паузы. Число сборщиков задается JVM-опцией:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">-XX:ParallelGCThreads=n</pre>
</div></div><p>Значение по умолчанию приблизительно равно 5/8 от количества логических процессоров. Если при данном значении есть подозрение на избыточность числа сборщиков, можно подбирать их количество из следующего ряда в порядке убывания: 1/2, 3/8, 1/4 от числа логических процессоров.</p><p><strong>Пример:</strong></p><p><span style="color: rgb(23,43,77);">Одна из ситуаций, когда могут возникнуть проблемы с завышенным количеством потоков —</span> высокая продолжительность фазы<span style="color: rgb(23,43,77);"> Termination </span>при низкой длительности остальных фаз<span style="color: rgb(23,43,77);">, в том числе Оbject copy (подробнее написано в строке log-файла ниже). В первую очередь стоит убедиться, что проблема не в операционной системе </span>и аппаратной части. Если с ними проблем нет<span style="color: rgb(23,43,77);">, можно снизить количество потоков.</span></p><p>Пример статистики для двух фаз: Object copy и Termination. Основной показатель — `Max`, так как в итоге фазы будут ждать самый «медленный» поток:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">GC(25)     Object Copy (ms):         Min: 175.7, Avg: 194.0, Max: 207.5, Diff: 31.8, Sum: 21920.2, Workers: 113
GC(25)     Termination (ms):         Min: 1008.6, Avg: 1021.1, Max: 1039.5, Diff: 30.9, Sum: 115388.8, Workers: 113</pre>
</div></div><h3 id="id-Настройкапроизводительности-Долгаяостановкапотоков">Долгая остановка потоков</h3><p><span style="color: rgb(23,43,77);">Если</span><span style="color: rgb(23,43,77);"><span> </span>время паузы в основном тратится не на операцию JVM, а на остановку потоков, дополнительные настройки сборки мусора не принесут прироста производительности.</span></p><h4 id="id-Настройкапроизводительности-Загрузкаоборудования">Загрузка оборудования</h4><p><span style="color: rgb(23,43,77);">Невозможность остановить потоки обычно обусловлена высокой нагрузкой на аппаратную часть и операционную систему узла. Часто такие задержки наблюдаются в сценариях с включенным Persistence и связаны с нагрузкой на дисковую подсистему. Если в GC-log появилось значительное время остановки потоков, проанализируйте нагрузку на железо во время появления паузы при помощи мониторинга DataGrid и других средств, например </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">nmon</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);"> (подробнее об отладке и мониторинге написано в следующем разделе). </span><br/><br/><span style="color: rgb(23,43,77);">Если загрузка устройств ввода-вывода близка к 100%, устраните причины перегрузки оборудования. Это необходимо при использовании продукта в сценариях с низкой задержкой. </span><br/><br/><span style="color: rgb(23,43,77);">Общие рекомендации:</span><br/><span style="color: rgb(23,43,77);">- горизонтально масштабировать систему с помощью добавления новых узлов;</span><br/><span style="color: rgb(23,43,77);">- добавить отдельные диски для хранения части данных Persistence (для увеличения пропускной способности каждого серверного узла). </span><br/><br/><span style="color: rgb(23,43,77);">Если выполняются тяжеловесные SQL-запросы или происходит снятие снепшота, </span><span style="color: rgb(23,43,77);">для снижения нагрузки на систему их можно выполнять в периоды наименьшей активности кластера.</span><br/><br/><span style="color: rgb(23,43,77);">Если паузы спровоцировало параллельное снятие снепшота, создавайте его без конкурентной нагрузки на кластер. Также установите или снизьте ограничение на скорость записи снепшота. Оно обеспечивается распределенным свойством </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">snapshotTransferRate</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">` — установите или снизьте для него порог скорости меньше заявленной производителем</span><span style="color: rgb(23,43,77);">. Например:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">./control.sh --property set --name snapshotTransferRate --val 1024

</pre>
</div></div><h4 id="id-Настройкапроизводительности-Дополнительнаяотладка">Дополнительная отладка</h4><p><span style="color: rgb(23,43,77);">Для подробной отладки причин проблем с остановкой потоков добавьте необязательные опции:</span><br/><br/><span style="color: rgb(23,43,77);">- </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:+SafepointTimeout</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);"> — выводит в log-файл информацию о потоках, у которых </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">time to safepoint</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);"> превысило предустановленный тайм-аут;</span><br/><span style="color: rgb(23,43,77);">- </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:SafepointTimeoutDelay</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);"> — если </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">time to safepoint</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);"> потока превысит данный тайм-аут и используется опция </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">-XX:+SafepointTimeout</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);">, в log-файл выведется информация о потоках.</span><br/><br/><span style="color: rgb(23,43,77);">Величина `Delay` (в миллисекундах) выбирается в зависимости от SLA/SLO проекта. Рекомендуемое значение — порядка 200–1000 мс. </span><br/><br/><span style="color: rgb(23,43,77);">В случае выставления этой пары опций в консоли приложения (поток </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">system.out</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);">) добавится список потоков, которые не смогли прийти в safepoint. В список будут включены от одного до нескольких потоков, которые не успели прийти в безопасное состояние за тайм-аут.</span><br/><br/><span style="color: rgb(23,43,77);">Пример вывода:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence"># SafepointSynchronize::begin: Timeout detected:
# SafepointSynchronize::begin: Timed out while spinning to reach a safepoint.
# SafepointSynchronize::begin: Threads which did not reach the safepoint:
# "kafka-producer-network-thread | producer-reliability-main-sender" #61 daemon prio=5 os_prio=0 cpu=131.89ms elapsed=1568.90s tid=0x00007f8aa4f3f180 nid=0x1ee9e1 runnable  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

# SafepointSynchronize::begin: (End of list)</pre>
</div></div><p><span style="color: rgb(23,43,77);">Место в коде, который выполняет данный поток (stacktrace), не выводится: получение stackt</span><span style="color: rgb(23,43,77);">race также требует попадания в safepoint.</span></p><h3 id="id-Настройкапроизводительности-BiasedLocking">Biased Locking</h3><p>Biased Locking — механизм JVM для оптимизации производительности приложений. По умолчанию включен; в JDK версии 15 и новее выключен.</p><p>В DataGrid версии 16.0 и новее в роли Biased Locking выключен по умолчанию.</p><p>Чтобы отключить механизм, выполните команду:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">-XX:-UseBiasedLocking</pre>
</div></div><h4 id="id-Настройкапроизводительности-ПоказаниядляотключенияBiasedLocking">Показания для отключения Biased Locking</h4><p>Один из признаков необходимости отключить Biased Locking — в log-файле `ignite.log` обнаружены сообщения `Possible too long JVM pause` штатного механизма<span> `</span>LongJVMPauseDetector`.</p><p>Пример сообщений в log-файле `ignite.log`:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">host0003    2023-06-21 14:49:04.247 [WARN ] Possible too long JVM pause: 922 milliseconds.
host0006    2023-06-21 12:43:31.934 [WARN ] Possible too long JVM pause: 943 milliseconds.
host0008    2023-06-20 13:06:55.858 [WARN ] Possible too long JVM pause: 787 milliseconds.
host0009    2023-06-21 16:30:02.976 [WARN ] Possible too long JVM pause: 1339 milliseconds.
host0020    2023-06-21 17:00:10.575 [WARN ] Possible too long JVM pause: 788 milliseconds.
host0022    2023-06-21 15:01:05.960 [WARN ] Possible too long JVM pause: 1590 milliseconds.
host0023    2023-06-20 19:12:14.859 [WARN ] Possible too long JVM pause: 1696 milliseconds.
host0024    2023-06-21 02:24:38.366 [WARN ] Possible too long JVM pause: 1236 milliseconds.
host0026    2023-06-20 14:20:25.998 [WARN ] Possible too long JVM pause: 887 milliseconds.
host0027    2023-06-21 16:00:50.630 [WARN ] Possible too long JVM pause: 515 milliseconds.
host0029    2023-06-21 16:16:14.633 [WARN ] Possible too long JVM pause: 963 milliseconds.
host0052  2023-06-21 04:24:15.077 [WARN ] Possible too long JVM pause: 648 milliseconds.
host0036    2023-06-20 16:16:03.847 [WARN ] Possible too long JVM pause: 884 milliseconds.
host0050    2023-06-21 17:32:29.900 [WARN ] Possible too long JVM pause: 626 milliseconds.
host0065    2023-06-21 17:32:37.160 [WARN ] Possible too long JVM pause: 576 milliseconds.
host0066    2023-06-19 02:28:15.263 [WARN ] Possible too long JVM pause: 986 milliseconds.
host0068    2023-06-21 17:25:23.123 [WARN ] Possible too long JVM pause: 1460 milliseconds.
host0036  2023-06-21 00:34:47.581 [WARN ] Possible too long JVM pause: 1024 milliseconds.
host0037  2023-06-21 17:09:23.944 [WARN ] Possible too long JVM pause: 518 milliseconds.
host0048  2023-06-21 16:54:51.620 [WARN ] Possible too long JVM pause: 611 milliseconds.
host0056    2023-06-21 17:47:36.148 [WARN ] Possible too long JVM pause: 1000 milliseconds.
host0060    2023-06-21 13:47:13.650 [WARN ] Possible too long JVM pause: 790 milliseconds.</pre>
</div></div><p><span style="color: rgb(23,43,77);">Следующий шаг — выполнить анализ log-файла </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">safepoint.log</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);">. Например, выявить длительность задержек с помощью утилиты </span><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><code><span class="style-TextCodeStyle__cls2 style-TextCodeStyle__cls1">grep</span></code><span class="style-TextPunctuation__cls2 style-TextPunctuation__cls1" style="color: rgb(23,43,77);">`</span><span style="color: rgb(23,43,77);">:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">grep "Total time for which application threads were stopped: " gc-safepoint.log.09 | grep -v "Total time for which application threads were stopped: 0"</pre>
</div></div><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">grep "Total time for which application threads were stopped: " gc-safepoint.log.09 | grep -v "Total time for which application threads were stopped: 0"
[2023-06-19T22:18:06.828+0300][75375.228s][safepoint         ] Total time for which application threads were stopped: 1.3670682 seconds, Stopping threads took: 1.3613468 seconds
[2023-06-20T01:51:06.595+0300][88154.995s][safepoint         ] Total time for which application threads were stopped: 1.1677948 seconds, Stopping threads took: 1.1582852 seconds


grep "Total time for which application threads were stopped: " gc-safepoint.log.45 | grep -v "Total time for which application threads were stopped: 0"
[2023-06-20T05:12:47.437+0300][1641602.236s][safepoint         ] Total time for which application threads were stopped: 1.0935892 seconds, Stopping threads took: 1.0928619 seconds
[2023-06-20T05:23:46.012+0300][1642260.811s][safepoint         ] Total time for which application threads were stopped: 1.4442415 seconds, Stopping threads took: 1.4393118 seconds</pre>
</div></div><p><span>Проверьте, является ли включенный Biased Locking причиной длительных safepoint, с помощью анализа JFR</span><span>:</span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img alt="" class="confluence-embedded-image" data-base-url="https://sberworks.ru/wiki" data-image-src="/wiki/download/attachments/410061476/biased_lock.png?version=1&amp;modificationDate=1713790576474&amp;api=v2" data-linked-resource-container-id="410061476" data-linked-resource-container-version="13" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="biased_lock.png" data-linked-resource-id="410061473" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" draggable="false" height="250" src="attachments/biased_lock.png"/></span></p><p>На изображении выше показано, что Java Mission Control (JMC) определил проблему <strong>Event Browser</strong> — <strong>Biased Locking Revocation</strong> — и вывел отчет на страницу <strong>Automated Analysis Results</strong>. Automated Analysis — автоматический анализ, который выполняется в JMC для всех JFR. В случае обнаружения подобных ошибок рекомендуется отключать Biased Locking.</p><p>В некоторых сценариях для повышения производительности стоит<span> </span>рассмотреть вариант использования сборщика мусора<span> </span>Shenandoah. Подробнее о нем написано ниже в разделе [<span>Shenandoah GC</span>](#s<span>henandoah-gc</span>).</p><h3 id="id-Настройкапроизводительности-AdaptiveIHOPиheapбольшогоразмера">Adaptive IHOP и heap большого размера</h3><p><span class="italic">IHOP (Initiating Heap Occupancy Percent или начальное заполнение heap)</span><span> — порог, при превышении которого запускается параллельная сборка мусора. Настройка задается в процентах от величины old-поколения. Сборщик G1 по умолчанию автоматически вычисляет оптимальную величину <span class="italic">IHOP, опираясь на то, сколько времени занимает стадия пометки объектов (Marking Phase) и сколько памяти во время нее обычно занято в old-поколении. Такая функция называется Adaptive IHOP. Когда эта функция активирована, опция `<code class="codeph">-XX:InitiatingHeapOccupancyPercent`</code> задает только изначальный размер IHOP, когда сборщик еще не собрал достаточно статистической информации для самостоятельного расчета данной величины.</span></span></p><p><span><span class="italic">Отключить такое поведение можно с помощью флага `<code class="codeph">-XX:-G1UseAdaptiveIHOP`</code>. В этом случае IHOP всегда будет задавать флаг `<code class="codeph">-XX:InitiatingHeapOccupancyPercent`.</code></span></span></p><p>На сравнительно больших размерах heap (десятки Гб)<span> </span><span><span class="italic">Adaptive IHOP срабатывает таким образом: после нескольких достаточно коротких сборок мусора следует тяжелая длинная сборка, которая в разы превышает предыдущие. Такое поведение GC может негативно сказаться на производительности и целостности кластера DataGrid. Если отключить Adaptive IHOP для больших heap и задать достаточно низкое значение для `<code class="codeph">-XX:InitiatingHeapOccupancyPercent`</code> (35% и ниже), сборки будут происходить чаще, но будут более короткими. </span></span></p><h3 id="id-Настройкапроизводительности-ShenandoahGC">Shenandoah GC</h3><h4 id="id-Настройкапроизводительности-Краткоеописание">Краткое описание</h4><p>Shenandoah — новый GC, который выпустили как часть JDK 12. Он сокращает GC-паузы за счет<span> </span>выполнения как можно большего количества работы по сборке мусора в параллельном режиме, то есть одновременно с работой основных потоков приложения. В основе инноваций Shenandoah лежит его региональное управление памятью. Heap стратегически разделен на регионы, что позволяет независимо вести сборку мусора в сегментах. Это не только способствует эффективному параллелизму,<span> </span><span style="color: rgb(23,43,77);">но и обеспечивает низкие задержки (low latency) при работе приложения.</span></p><h4 id="id-Настройкапроизводительности-ОтличияотG1">Отличия от G1</h4><p>Ключевое преимущество Shenandoah перед G1: большая часть цикла сборки мусора выполняется одновременно с потоками приложений. G1 может эвакуировать области heap только во время остановки приложения, а Shenandoah перемещает объекты одновременно с ним.</p><p>Shenandoah может очищать мусор и освобождать оперативную память почти сразу после обнаружения свободной памяти. Поскольку это происходит без остановки работы приложения, Shenandoah более интенсивно нагружает процессор.<span> </span>Также<span> </span>Shenandoah  выполняет одновременное уплотнение (concurrent compaction): время<span> </span>паузы больше не<span> </span>пропорционально размеру heap.</p><h4 id="id-Настройкапроизводительности-Когдаиспользовать">Когда использовать</h4><p>Стоит рассматреть возможность использования Shenandoah GC для приложения, если есть следующие требования:</p><ul><li><strong>Low-Latency решения.<span> </span></strong>Shenandoah GC подходит для приложений, которые требуют неизменно низкого времени паузы для поддержания оптимального пользовательского опыта. Это включает сценарии финансовых систем, онлайн-игровых платформ и приложений в реальном времени.</li><li><strong>Большие размеры heap.<span> </span></strong>В приложениях со значительным потреблением памяти Shenandoah GC минимизирует время паузы во время сборки мусора. Примеры таких приложений: системы обработки больших данных, базы данных в памяти (IMDB) и системы корпоративного уровня с обширными наборами данных.</li><li><strong>Предсказуемое время отклика.</strong><span> </span>Shenandoah GC подходит в ситуациях, когда непредсказуемые и длительные паузы неприемлемы и поддержание предсказуемого времени отклика имеет решающее значение. Это особенно актуально для интерактивных веб-приложений, где взаимодействие пользователей должно привести к немедленным ответам.</li><li><strong>Динамические рабочие нагрузки.</strong><span> </span>Shenandoah GC подходит для приложений, которые испытывают колеблющиеся рабочие нагрузки. Shenandoah GC адаптируется к динамическим требованиям сбора мусора. Это включает масштабируемые веб-сервисы и приложения с различной активностью пользователя в течение дня.</li></ul><h4 id="id-Настройкапроизводительности-Какиспользовать"><span class="inline-comment-marker" data-ref="939d17a5-4c1d-4c22-b503-cb95600a508b">Как использовать</span></h4><p><span style="color: rgb(23,43,77);">Убедитесь, что версия Java поддерживает Shenandoah GC. Shenandoah доступен в OpenJDK версии 11 и новее. Также можно использовать коммерческие дистрибутивы JDK, например Oracle JDK или ascistopenjdk. JVM-опция для включения Shenandoah GC:</span><span style="color: rgb(23,43,77);"> `</span><span style="color: rgb(23,43,77);">-XX:+UseShenandoahGC`.</span></p><h4 id="id-Настройкапроизводительности-Обязательныеопции">Обязательные опции</h4><p>Некоторые обязательные настройки <span>Shenandoah GC</span>:</p><ul><li>`-XX: ShenandoahHeapCriticalPercent` указывает процент<span> </span>заполнения<span> </span>heap, при котором происходят эвакуационные паузы. Увеличение этого значения может снизить частоту эвакуационных<span> </span>пауз.</li><li>`-XX: ShenandoahMaxEvacuationPauseMillis` устанавливает максимально желаемое время эвакуационной паузы. Более низкие значения снижают время паузы, но могут привести к увеличению использования центрального процессора.</li><li>`-XX: ShenandoahInitFreeThreshold` устанавливает начальный порог для количества свободного пространства в heap. Регулировка этого значения может помочь в управлении темпами роста heap.</li></ul><h4 id="id-Настройкапроизводительности-Дополнительныерекомендуемыеопции">Дополнительные рекомендуемые опции</h4><p><span>Shenandoah GC предоставляет несколько дополнительных настроек для оптимизации поведения на основе потребностей приложения:</span></p><ul><li>`-Xx:+AlwessPreTouch`<span> </span>— аргумент JVM, который<span> </span><span style="color: rgb(23,43,77);">гарантирует аллокацию физической, а не виртуальной памяти для heap при инициализации JVM. Сводит к минимуму паузы во время выполнения приложений, но увеличивает время запуска JVM.</span></li><li>`-Xms`<span> </span><span>устанавливает начальный размер <span style="color: rgb(23,43,77);">heap</span>, когда запускается JVM.</span><span> `</span>-Xmx`<span> </span><span>устанавливает максимальный размер <span style="color: rgb(23,43,77);">heap</span>, который может использовать JVM. Чтобы обеспечить фиксированный и не расширяемый размер <span style="color: rgb(23,43,77);">heap</span>, установите одинаковые значения для обоих параметров. Эта конфигурация уменьшает задержки, которые связаны с управлением <span style="color: rgb(23,43,77);">heap</span>, и обеспечивает стабильность и предсказуемое использование памяти для приложения.</span></li><li>`-Xx:-UseBiasedLocking` отключает механизм привязанных блокировок (Biased Locking). Он неэффективен в приложениях, где требуется низкая задержка (low latency). Использование данной опции уменьшает потенциальные задержки при работе приложения (подробнее написано в разделе выше).</li><li>`-XX:+DisableExplicitgcGC`<strong><span> </span></strong>запрещает запускать чистку мусора при помощи `<span style="color: rgb(65,65,65);">System.gc()` — это</span><span style="color: rgb(23,43,77);"><span> </span>защищает приложение от чрезмерного вызова чисток из кода.</span></li></ul><h2 id="id-Настройкапроизводительности-НеоптимальнаянастройкаDataGrid"><span class="inline-comment-marker" data-ref="37487c03-d5cf-44d3-9cf2-47a2be3791ff">Неоптимальная настройка DataGrid</span></h2><h3 id="id-Настройкапроизводительности-Общиерекомендации">Общие рекомендации</h3><p>Список общих рекомендаций по настройке DataGrid:</p><ul><li>Развертывайте и тестируйте кластер не с одним, а с несколькими узлами. DataGrid разработан и оптимизирован для сценариев распределенных вычислений. Например, на приближенной к целевой конфигурации при тестировании кластера с одним узлом сеть будет исключена из работы. Работа кластера чувствительна к работе сети. Чем ближе тестируемая конфигурация к целевой, тем более релевантными и показательными будут результаты.</li><li>Выделите узлу базы данных необходимое количество доступных на локальном компьютере ресурсов центрального процессора (ЦП) и ОЗУ. Количество ресурсов, которые требуются для работы, определяется с помощью нагрузочного тестирования (НТ).</li><li>Если DataGrid развернут в виртуальной или облачной среде, оптимальной конфигурацией будет размещение одного узла DataGrid на одном хосте. Так DataGrid не будет конкурировать за ресурсы хоста с другими приложениями, это не вызовет скачков производительности кластера и позволит обеспечить высокую доступность. Выход хоста из строя может привести к потере данных, если к нему прикреплено более одного серверного узла DataGrid.</li><li>По возможности храните весь набор данных в ОЗУ и предварительно скорректируйте модель данных и существующие приложения. Архитектура DataGrid прежде всего ориентируется на хранение данных в памяти, хотя может хранить данные и работать с ними на диске.</li><li>На этапе проектирования данных учитывайте особенности решения. Продумайте, как правильно распределить данные с учетом возможностей совместного размещения (colocation). Чем больше данных кешируется в ОЗУ, тем выше производительность, поэтому важно правильно сконфигурировать и настроить память.</li><li>При включенном Native Persistence используйте характерные для режима методы оптимизации. Подробнее об этом написано <span style="color: rgb(23,43,77);">в разделе [«Настройка Persistence»](..<span class="">/</span>../developer-guide/md/setting_up_persistence.md</span><span style="color: rgb(23,43,77);">) документа «Руководство прикладного разработчика».</span></li><li>При работе с SQL оптимизируйте SQL-запросы. Подробнее об этом написано в<span> следующем разделе</span>.</li><li><span style="color: rgb(23,43,77);">Используйте настройки ребалансировки для минимизации времени переноса данных между узлами при изменении топологии кластера.</span></li></ul><h3 id="id-Настройкапроизводительности-НастройкапроизводительностиSQL">Настройка производительности SQL</h3><p><span style="color: rgb(23,43,77);">Ниже указаны рекомендации при работе с SQL-запросами.</span></p><h4 id="id-Настройкапроизводительности-Анализируйтепланзапросов">Анализируйте план запросов</h4><p><span style="color: rgb(23,43,77);">Для поиска возможностей по оптимизации SQL-запросов изучите план запроса с помощью оператора `EXPLAIN`. Последняя строка вывода содержит информацию о `REDUCE`-запросе, остальные строки — о `MAP`-запросах.</span></p><p>Примеры:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">EXPLAIN SELECT * FROM City;
+-------------------------------------------------------------------------------------------+
|                                           PLAN                                            |
+-------------------------------------------------------------------------------------------+
| SELECT
    CITY.ID,
    CITY.NAME
FROM PUBLIC.CITY
    /* PUBLIC."IDX_CITY_NAME_proxy" */ |
+-------------------------------------------------------------------------------------------+</pre>
</div></div><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">EXPLAIN SELECT p.name, c.name FROM Person p, City c WHERE p.city_id = c.id;
+-----------------------------------------------------------------------------------------------------+
|                                           PLAN                                                                          |
+-----------------------------------------------------------------------------------------------------+
| SELECT
    P__Z0.NAME AS __C0_0,
    C__Z1.NAME AS __C0_1
FROM PUBLIC.PERSON P__Z0
    /* PUBLIC.PE |
| SELECT
    __C0_0 AS NAME,
    __C0_1
FROM PUBLIC.__T0
    /* PUBLIC."merge_scan" */                |
+-----------------------------------------------------------------------------------------------------+</pre>
</div></div><h4 id="id-Настройкапроизводительности-Неустанавливайтелишниеиндексынаполя">Не устанавливайте лишние индексы на поля</h4><p>В DataGrid есть полная поддержка индексов. Найдите комбинацию индексов, которая обеспечит наилучшую производительность.</p><p>Не индексируйте каждое поле в таблице — это увеличивает объем используемой памяти.</p><p>Используйте план запросов для анализа используемых индексов и не устанавливайте индексы на неиспользуемые поля.</p><h4 id="id-Настройкапроизводительности-Используйтегрупповыеиндексы">Используйте групповые индексы</h4><p><span style="color: rgb(23,43,77);">Групповые индексы (индексы с несколькими полями) могут ускорить запросы со сложными условиями. Чтобы добавить групповые индексы, используйте аннотацию `@QuerySqlField.Group`.</span></p><h4 id="id-Настройкапроизводительности-Отрегулируйтеразмерстраницы">Отрегулируйте размер страницы</h4><p><span style="color: rgb(23,43,77);">Выбранный размер страницы может повлиять на производительность базы данных. При выборе размера страницы дополнительно протестируйте производительность вместе с другими аспектами поведения.</span></p><h4 id="id-Настройкапроизводительности-ВнимательноиспользуйтеоператорOR">Внимательно используйте оператор OR</h4><p>Логика применения индекса может меняться при использовании в запросе оператора `OR`.</p><p>В примере индекс для `gender` будет использоваться вместо индекса для `age`:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT name FROM Person WHERE gender='M' and (age = 20 or age = 30)</pre>
</div></div><p><span style="color: rgb(23,43,77);">Решение — разделить запрос на части и использовать оператор `UNION ALL`:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT name FROM Person WHERE gender='M' and age = 20
UNION ALL
SELECT name FROM Person WHERE gender='M' and age = 30</pre>
</div></div><p><br/></p><p>&gt; <strong>Внимание<br/></strong>&gt;<br/>&gt; Использование оператора `UNION` без `ALL` вернет `DISTINCT` строки. Это изменит семантику SQL-запроса и снизит его производительность.</p><h4 id="id-Настройкапроизводительности-НеиспользуйтеслишкоммногоколоноквзапросеSELECT">Не используйте слишком много колонок в запросе SELECT</h4><p>Запросы со 100 и более колонками могут работать хуже ожидаемого. Это ограничение парсера запросов H2.</p><h4 id="id-Настройкапроизводительности-Используйтеcolocatedдлязапросовсгруппировкой">Используйте colocated для запросов с группировкой</h4><p>Если данные коллоцированы по правилу (по полям) группировки, используйте `colocated` для запросов с группировкой.</p><p>При группировке запрашиваемых данных через `GROUP BY` используйте `SqlFieldsQuery.collocated = true`, чтобы механизм SQL выполнил группировку на удаленных узлах. Это уменьшит сетевой трафик между узлами и время выполнения запросов.</p><p>Сравним два примера.</p><p><strong>Пример 1:</strong></p><p>Данные размещены по affinity-ключу `department_id`.</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT SUM(salary) FROM Employee GROUP BY department_id</pre>
</div></div><p><span style="color: rgb(23,43,77);">DataGrid суммирует зарплаты сотрудников по элементам, которые хранятся на отдельных узлах, и отправляет эти суммы на удаленный узел для окончательного результата. Эта операция уже распределена, включение флага</span><span style="color: rgb(23,43,77);"> `</span><span style="color: rgb(23,43,77);">colocated` незначительно повысит производительность.</span></p><p><strong><span style="color: rgb(23,43,77);">Пример 2:</span></strong></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT AVG(salary) FROM Employee GROUP BY department_id</pre>
</div></div><p><span style="color: rgb(23,43,77);">DataGrid вычислит средние значения для каждого отдела на разных узлах и отправит данные на удаленный узел для расчета финального результата. Установка<span> `</span></span><span style="color: rgb(23,43,77);">SqlFieldsQuery.collocated = true`</span><span style="color: rgb(23,43,77);"><span> </span>сократит время выполнения запроса.</span></p><h4 id="id-Настройкапроизводительности-ИспользуйтетипTIMESTAMPвместоDATE">Используйте тип TIMESTAMP вместо DATE</h4><p><span style="color: rgb(23,43,77);">Тип `DATE` неэффективно сериализуется и десериализуется. Это приводит к снижению производительности.</span></p><h4 id="id-Настройкапроизводительности-ПорядоквыполненияJOIN">Порядок выполнения JOIN</h4><p>Если установлен флаг<span> `</span>SqlFieldsQuery.setEnforceJoinOrder(true)`, оптимизатор запросов не будет менять порядок таблиц в соединениях. Порядок, в котором применяются объединения во время выполнения запроса, будет таким же, как указано в запросе.</p><p>Без этого флага оптимизатор запросов может изменить порядок соединений для повышения производительности. Иногда он может принять неверное решение. Флаг помогает контролировать и явно указывать порядок соединений, не полагаясь на оптимизатор.</p><p>Пример:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT * FROM Person p
JOIN Company c ON p.company = c.name where p.name = 'John Doe'
AND p.age &gt; 20
AND p.id &gt; 5000
AND p.id &lt; 100000
AND c.name NOT LIKE 'O%';</pre>
</div></div><p><span style="color: rgb(23,43,77);">Оператор `JOIN` соединяет результаты запроса из двух таблиц: Person и Company. Для улучшения производительности стоит понимать, какой подзапрос вернет наименьший набор результатов. Таблицу с наименьшим набором результатов нужно указывать первой в паре соединения.</span></p><p>Запрос 1:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT count
FROM Person p
WHERE
p.name = 'John Doe'
AND p.age &gt; 20
AND p.id &gt; 5000
AND p.id &lt; 100000;</pre>
</div></div><p>Запрос 2:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT count
FROM Company c
where
c.name NOT LIKE 'O%';</pre>
</div></div><p><span style="color: rgb(23,43,77);">Первый запрос дает 30 000 записей, а второй — 100 000 записей, поэтому менять порядок записей не нужно. Следовательно, не нужно менять порядок в запросе.</span></p><h4 id="id-Настройкапроизводительности-Параллелизмзапросов"><span class="inline-comment-marker" data-ref="bd7719ba-8e6a-4278-85f9-098e36f58618">Параллелизм запросов</span></h4><p><span style="color: rgb(23,43,77);">По умолчанию SQL-запрос выполняется в одном потоке на каждом участвующем узле. Этот подход оптимален для запросов, которые возвращают небольшие наборы результатов, включающих поиск по индексу, например:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT * FROM Person WHERE p.id = ?;</pre>
</div></div><p><span style="color: rgb(23,43,77);">Некоторые запросы могут выиграть от выполнения в нескольких потоках. Это относится к запросам на сканирование таблиц и агрегирование. Они наиболее</span><span style="color: rgb(23,43,77);"> характерны для систем обработки данных OLAP и HTAP.</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT SUM(salary) FROM Person;</pre>
</div></div><p>Количество потоков, которые создаются на одном узле для выполнения запросов, настраивается для каждого кеша и по умолчанию равно `1`. Можно изменить это значение с помощью параметра `CacheConfiguration.queryParallelism`. При создании SQL-таблицы с помощью команды `CREATE TABLE` для установки параметра можно использовать шаблон кеша.</p><p>Если запрос содержит `JOIN`, у всех участвующих кешей должна быть одинаковая степень параллелизма.</p><h4 id="id-Настройкапроизводительности-Используйтеподсказкииндекса">Используйте подсказки индекса</h4><p><span style="color: rgb(23,43,77);">Подсказки индекса полезны в сценариях, в которых известно, что один индекс больше подходит для определенных запросов, чем другой. Используйте подсказки, чтобы указать оптимизатору запросов на выбор более эффективного плана выполнения. Для этого используйте оператор `USE INDEX(indexA,...,indexN)`, как показано в примере:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT * FROM Person USE INDEX(index_age)
WHERE salary &gt; 150000 AND age &lt; 35</pre>
</div></div><h4 id="id-Настройкапроизводительности-Используйтеaffinity-ключивусловииWHERE">Используйте affinity-ключи в условии WHERE</h4><p><span style="color: rgb(23,43,77);">Для оптимизации запросов используйте affinity-ключи в условии `WHERE`.</span><span> </span>При выполнении такого запроса DataGrid сканирует только те партиции, где хранятся запрошенные данные. Это сокращает время запроса, так как он отправляется только тем узлам, на которых хранятся запрошенные партиции.</p><p>В примере ниже объекты сотрудников<span> </span><span style="color: rgb(23,43,77);">распределяются по партициям и узлам</span> по полю идентификатора. Если affinity-ключ не задан явно, вместо него используется первичный ключ:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">CREATE TABLE employee (id BIGINT PRIMARY KEY, department_id INT, name VARCHAR)
/* Запрос отправляется узлу, на котором хранится требуемый ключ. */
SELECT * FROM employee WHERE id=10;
/* Запрос отправляется всем узлам. */
SELECT * FROM employee WHERE department_id=10;</pre>
</div></div><p>В примере ниже affinity-ключ задается явно и используется для совместного размещения данных и прямых запросов узлам, которые хранят первичные копии данных:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">CREATE TABLE employee (id BIGINT PRIMARY KEY, department_id INT, name VARCHAR) WITH "AFFINITY_KEY=department_id"
/* Запрос отправляется всем узлам. */
SELECT * FROM employee WHERE id=10;
/* Запрос отправляется узлу, на котором хранится требуемый ключ. */
SELECT * FROM employee WHERE department_id=10;</pre>
</div></div><p><span style="color: rgb(23,43,77);">Подробнее о коллокации написано в подразделе [«Колокация вычислений с данными»](..<span class="">/</span>../developer-guide/md/collocation_of_calculations_with_data.md</span><span style="color: rgb(23,43,77);">) документа «Руководство прикладного разработчика».</span></p><h4 id="id-Настройкапроизводительности-ПропускайтеузелReducerприобновлении">Пропускайте узел Reducer при обновлении</h4><p>DataGrid при выполнении DML-операций (Data Manipulation Language) сначала извлекает все затронутые промежуточные строки для анализа на узел Reducer (обычно это приложение пользователя) и затем готовит измененные значения для отправки на удаленные узлы.</p><p>Такой подход может повлиять на производительность и перегрузить сеть, если DML-операция должна переместить много записей.</p><p>Используйте флаг<span> `</span>skipReducerOnUpdate=true`<span> </span>в качестве подсказки для механизма SQL, чтобы выполнить анализ всех промежуточных строк и обновления «на месте» на узлах сервера. Подсказка поддерживается для соединений JDBC и ODBC.</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">// Строка JDBC-соединения.
jdbc:ignite:thin://192.168.0.15/skipReducerOnUpdate=true</pre>
</div></div><h4 id="id-Настройкапроизводительности-УвеличьтеINDEXINLINESIZE">Увеличьте INDEX INLINE SIZE</h4><p>У каждой записи в индексе есть постоянный размер, который рассчитывается при его создании. `INDEX INLINE SIZE` — встроенный размер индекса. В идеале этого размера должно быть достаточно для хранения полной проиндексированной записи в сериализованном виде. Если значения не полностью включены в индекс, DataGrid может потребоваться выполнить чтение дополнительных страниц данных во время поиска по индексу. Это может снизить производительность при включенной персистентности данных.</p><p>Для примитивных типов данных (`bool`, `byte`, `short`, `int` и так далее) DataGrid автоматически вычисляет встроенный размер индекса, чтобы значения включались полностью. Например, для полей `int` встроенный размер равен 5 байтам (1 байт для тега и 4 байта для самого значения). Для<span style="color: rgb(23,43,77);"> полей `long`</span> встроенный размер равен 9 байтам (1 байт для тега и 8 байт для значения).</p><p>Индекс бинарных объектов включает хеш каждого объекта — этого достаточно, чтобы избежать коллизий.</p><p><span class="inline-comment-marker" data-ref="b98957b7-a381-4cea-adbf-08012ae4e6d2">Для данных переменной длины индексы включают только первые несколько байтов значения. При индексировании полей с данными переменной длины рекомендуется самостоятельно оценить длину значения поля и установить встроенный размер, который включает большинство (около 95%) или все значения. Пример: если есть строковое поле, 95% значений которого содержат 10 или менее символов, можно установить встроенный размер индекса в этом поле равным `13`.</span></p><p>Встроенные размеры применяются к индексам с одним полем. При самостоятельном определении индекса для поля в объекте значения или для столбца, который не является первичным ключом, DataGrid создает составной индекс: добавляет первичный ключ к индексированному значению. При расчете встроенного размера для составных индексов суммируйте встроенный размер первичного ключа.</p><p>Пример<span> </span>расчета<span> </span>встроенного размера индекса для кеша, в котором ключ и значение — сложные объекты:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Key {         
@QuerySqlField       
private long id;             
@QuerySqlField        
@AffinityKeyMapped         
private long affinityKey;    
}

public class Value {       
@QuerySqlField(index = true)    
private long longField;          
@QuerySqlField(index = true)       
private int intField;           
@QuerySqlField(index = true)       
private String stringField;     
}</pre>
</div></div><p>Подсчет размера индекса для объекта из примера выше:</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><th class="confluenceTh" scope="col">Индекс</th><th class="confluenceTh" scope="col">Тип</th><th class="confluenceTh" scope="col"><p><strong>Рекомендованный размер в байтах</strong></p></th><th class="confluenceTh" scope="col">Комментарий</th></tr><tr><td class="confluenceTd" style="text-align: left;"><p class="tableblock"><span class="inline-comment-marker" data-ref="48d56aa8-f46e-42be-8f8e-63eb33a4f794">`(_key)`</span></p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock"><span class="inline-comment-marker" data-ref="1f675551-6b1a-4e5d-89e8-f55c83f2c521">Primary key index</span></p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock"><span class="inline-comment-marker" data-ref="1aaf77be-cb7a-4308-ab3c-1b8457c4fcd7">5</span></p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock"><span class="inline-comment-marker" data-ref="97122d91-b649-426c-989d-ae41bb72e88c">Inlined hash of a binary object (5)</span></p></td></tr><tr><td class="confluenceTd" style="text-align: left;"><p class="tableblock">`(affinityKey, _key)`</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Affinity key index</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">14</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Inlined long (9) + binary object’s hash (5)</p></td></tr><tr><td class="confluenceTd" style="text-align: left;"><p class="tableblock">`(longField, _key)`</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Secondary index</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">14</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Inlined long (9) + binary object’s hash (5)</p></td></tr><tr><td class="confluenceTd" style="text-align: left;"><p class="tableblock">`(intField, _key)`</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Secondary index</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">10</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Inlined int (5) + binary object up to hash (5)</p></td></tr><tr><td class="confluenceTd" style="text-align: left;"><p class="tableblock">`(stringField, _key)`</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Secondary index</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">18</p></td><td class="confluenceTd" style="text-align: left;"><p class="tableblock">Inlined string (13) + binary object’s hash (5) (assuming that the string is ~10 symbols)</p></td></tr></tbody></table></div><p><br/></p><p>&gt; <strong>Внимание<br/></strong>&gt;<br/>&gt; <span style="color: rgb(23,43,77);">Установите встроенный размер только для индекса в `stringField`. Для других индексов DataGrid автоматически вычисляет встроенный размер.</span></p><p><span style="color: rgb(23,43,77);">Проверить встроенный размер существующего индекса можно в системном представлении `INDEXES`.</span></p><h2 id="id-Настройкапроизводительности-НастройкаPersistence">Настройка Persistence</h2><p><span style="color: rgb(23,43,77);">Корректная настройка персистентности DataGrid напрямую влияет на производительность. Рекомендуется изучить методики настройки перед началом работы.</span></p><p>Подробнее о настройке размера страниц, WAL, Checkpoint-буфера и прямого ввода-вывода написано в разделе [«Настройка Persistence»](<span style="color: rgb(23,43,77);">..<span class="">/</span>../developer-guide/md/setting_up_persistence.md</span>) документа «Руководство прикладного разработчика».</p><h2 id="id-Настройкапроизводительности-Дополнительныерекомендации">Дополнительные рекомендации</h2><h3 id="id-Настройкапроизводительности-Задержкаипропускнаяспособность">Задержка и пропускная способность</h3><p>Основные метрики измерения производительности:</p><ul><li>latency (задержка) — время отдельной операции;</li><li>throughput (пропускная способность) — количество выполненных операций за период времени.</li></ul><p>У этих метрик обратная зависимость. Например, увеличение количества одновременных операций на одном и том же объеме ресурсов приведет к росту пропускной способности и увеличению задержки. Важно понимать, какую метрику требуется улучшить.</p><h4 id="id-Настройкапроизводительности-Задержка"><strong>Задержка</strong></h4><p>Масштабирование (добавление новых узлов) позволит уменьшить задержку. Перед выполнением масштабирования установите источник проблем с производительностью. Во многих случаях добавление новых узлов сразу даст положительный результат.</p><h4 id="id-Настройкапроизводительности-Пропускнаяспособность"><strong>Пропускная способность</strong></h4><p><span style="color: rgb(23,43,77);">Если пропускная способность важнее задержки, используйте пакетирование (группировку операций пакетами)<span> `</span></span><span style="color: rgb(23,43,77);">getAll()`</span><span style="color: rgb(23,43,77);">, `</span><span style="color: rgb(23,43,77);">putAll()`</span><span style="color: rgb(23,43,77);">, `</span><span style="color: rgb(23,43,77);">invokeAll()`</span><span style="color: rgb(23,43,77);"><span> </span>или `DataStreamer`<span> — подробнее об этом написано ниже в разделе [IgniteDataStreamer](#ignitedatastreamer)</span></span><span style="color: rgb(23,43,77);">. В данных операциях batch (пакет) ключей распределяется по узлам-владельцам партиций и отправляется на каждый узел единым пакетом. Его размер можно выбрать опытным путем, избегая крайних значений.</span></p><p>Группировка операций пакетами уменьшит количество сетевых сообщений в системе и повысит пропускную способность. Обычно это увеличивает задержку, так как первая операция в пакете будет ждать последнюю: задержка первой операции будет высокой.</p><p>Используйте пакетирование, если задержка отдельного обновления или чтения важна меньше количества операций за промежуток времени.</p><p>Пакетная операция<span> `</span>getAll()`<span> </span>позволяет получить несколько записей кеша в одном вызове. Для этого передается множество ключей, и DataGrid возвращает map (отображение) соответствующих значений:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@IgniteAsyncSupported
Map&lt;K,V&gt; getAll(Set&lt;? extends K&gt; keys)
throws TransactionException 
Определяется:
getAll in interface javax.cache.Cache&lt;K,V&gt; 
Генерирует:
Исключение `TransactionException`, если операция внутри транзакции завершилась неуспешно.</pre>
</div></div><p><span style="color: rgb(23,43,77);">Операция<span> `</span></span><span style="color: rgb(23,43,77);">putAll()`</span><span style="color: rgb(23,43,77);"><span> </span>позволяет добавить или обновить несколько записей кеша в одном вызове. Для этого передается map (отображение) пар «ключ-значение» и операция добавляет записи в кеш:</span></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@IgniteAsyncSupported
void putAll(Map&lt;? extends K,? extends V&gt; map)
throws TransactionException 
Ключи блокируются в том порядке, в котором они отображаются в map. Тот, кто выполнил вызов, должен убедиться, что ключи всегда следуют в одном и том же порядке — например с помощью `TreeMap`. Использование неупорядоченного отображения, например `HashMap`, при параллельном вызове этого метода приведет к взаимоблокировке.

Определяется:
putAll in interface javax.cache.Cache&lt;K,V&gt; 
Генерирует:
Исключение `TransactionException`, если операция внутри транзакции завершилась неуспешно.</pre>
</div></div><p><span>`</span>invokeAll()`<span> </span>позволяет выполнить вычислительные операции над несколькими записями кеша в одном вызове.<span> `</span>Cache.invokeAll()`<span> </span>принимает два аргумента: функцию для вычислений и коллекцию ключей. Функция определяется пользователем и выполняется над значениями, которые связаны с ключами в кеше.</p><p>Коллекция ключей определяет множество записей, над которыми выполняется вычислительная операция:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@IgniteAsyncSupported
&lt;T&gt; Map&lt;K,javax.cache.processor.EntryProcessorResult&lt;T&gt;&gt; invokeAll(Map&lt;? extends K,? extends javax.cache.processor.EntryProcessor&lt;K,V,T&gt;&gt; map,
Object... args)  

Параметры типа:
`T` — тип результата обработки записи кеша. 
Параметры:
- `map` — отображение, содержащее ключи и `EntryProcessors`, которые будут применены к значениям.
- `args` — дополнительные аргументы для передачи `EntryProcessor`.
Возвращает:
Отображение `EntryProcessorResults` обработки для каждого ключа (если применимо), который определяется реализацией `EntryProcessor`. Для `EntryProcessors`, которые возвращают нулевое значение для ключа, сопоставления (mappings) не вернутся.
Генерирует:
Исключение `TransactionException`, если операция внутри транзакции завершилась неуспешно.</pre>
</div></div><p><span style="color: rgb(23,43,77);">При вызове<span> `</span></span><span style="color: rgb(23,43,77);">invokeAll()`</span><span style="color: rgb(23,43,77);"><span> </span>для кеша DataGrid с несколькими ключами можно указать `EntryProcessor`, который будет выполняться для каждой пары «ключ-значение». Метод<span> `</span></span><span style="color: rgb(23,43,77);">invokeAll()`</span><span style="color: rgb(23,43,77);"><span> </span>отправляет `EntryProcessor` основному (primary) узлу-владельцу каждого ключа. Основной узел выполняет `EntryProcessor` для пары «ключ-значение» и отправляет обновленное значение обратно вызывающей стороне.</span></p><p>Пример:</p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">IgniteCache&lt;String, Integer&gt; cache = ignite.getOrCreateCache("myCache");
Map&lt;String, EntryProcessorResult&lt;Integer&gt;&gt; result = cache.invokeAll(
    Arrays.asList("key1", "key2", "key3"),
    new EntryProcessor());</pre>
</div></div><h3 id="id-Настройкапроизводительности-IgniteDataStreamer">IgniteDataStreamer</h3><p>Кроме пакетных операций, которые описаны в разделе выше, для массовой загрузки данных (bulk loading) можно использовать<span> `</span>IgniteDataStreamer`<strong><span> </span></strong>— высокопроизводительный инструмент для заливки больших объемов информации в кеш DataGrid. `IgniteDataStreamer` выполняет автоматическое пакетирование, его можно использовать для загрузки данных из различных источников. Подробнее о нем написано в разделе [Data Streaming](<span style="color: rgb(23,43,77);">..<span class="">/</span>../developer-guide/md/data_streaming.md</span>) документа «Руководство прикладного разработчика».</p><p>При использовании<span> </span>API `IgniteDataStreamer` для конкретного кеша:</p><ol><li>Создайте поток данных.</li><li>Для каждой записи, которую нужно сохранить в кеше, вызовите метод `addData()`:<br/><br/></li></ol><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">try (IgniteDataStreamer&lt;Integer, String&gt; streamer = ignite.dataStreamer("my-cache")){
    for (int i = 0; i &lt; ENTRY_COUNT; i++)
    streamer.addData(i, Integer.toString(i));
}</pre>
</div></div><p>Метод<span> `</span>addData()`<span> </span>асинхронный — он не сохраняет запись в кеше и не выполняет никаких операций.<span> </span>Вместо этого он добавляет запись в `DataStreamer`, и он принимает решение, когда стоит очистить запись.</p><p>В `IgniteDataStreamer` есть несколько настраиваемых параметров, например размер пакета данных и тайм-аут для очистки очереди, даже если она еще не заполнена. <span style="color: rgb(23,43,77);">Подробнее об `IgniteDataStreamer` написано в разделе [Data Streaming](..<span class="">/</span>../developer-guide/md/data_streaming.md</span><span style="color: rgb(23,43,77);">) документа «Руководство прикладного разработчика».</span></p><p>Один из важных параметров — флаг<span> `</span>allowOverWrite`. Если у него установлено значение `false` (по умолчанию):</p><ul><li><p>в потоковых данных не должно быть повторяющихся ключей;</p></li><li>отключение `DataStreamer` или сбой потокового узла может привести к неконсистентности данных;</li><li><span style="color: rgb(23,43,77);">снепшот, который сняли во время загрузки данных в Persistent-кеше, может содержать неконсистентные данные (без возможности восстановления их консистентности).</span></li></ul><p>Если `DataStreamer` загрузит данные с флагом<span> `</span>allowOverwrite==false`<span> </span>без гарантий констистентности данных, сгенерируется исключение снепшота.</p><p>`DataStreamer` не гарантирует:</p><ul><li>по умолчанию — консистетность данных до успешного завершения их загрузки;</li><li>незамедлительное начало загрузки данных, так как перед ее началом возможна задержка;</li><li>порядок данных, так как их записи могут быть загружены в кеш не в том порядке, в котором их загрузили в `DataStreamer`.</li></ul><p><br/></p></main>
</body>
</html>